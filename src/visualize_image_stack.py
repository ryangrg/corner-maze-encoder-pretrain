import re
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union

import matplotlib.pyplot as plt
import numpy as np
import torch
from matplotlib.widgets import Button, TextBox

ROOT_DIR = Path(__file__).resolve().parents[1]
DEFAULT_DUPLICATE_CSV = ROOT_DIR / "data/pt-files/dedup-all-images-equalized-dataset-52-1-05.csv"
DEFAULT_DATASET_BUNDLE = ROOT_DIR / "data/pt-files/all-images-equalized-dataset-duplicates-52-1-05.pt"

@dataclass(frozen=True)
class StereoPair:
    base: str
    left_path: Optional[Path]
    right_path: Optional[Path]

def load_dataset_bundle(
    bundle_path: Path,
    map_location: Union[str, torch.device] = "cpu",
) -> Tuple[torch.Tensor, List[StereoPair], Dict[str, Any]]:
    """
    Load a serialized dataset generated by create_dataset.py.

    Args:
        bundle_path: Path to the .pt file containing the dataset payload.
        map_location: Device specification passed to torch.load.

    Returns:
        A tuple of (tensor stack, metadata list, meta dictionary).
    """
    resolved_path = bundle_path.expanduser().resolve()
    if not resolved_path.exists():
        raise FileNotFoundError(f"Dataset file not found: {resolved_path}")

    payload = torch.load(resolved_path, map_location=map_location)
    if not isinstance(payload, dict):
        raise TypeError(f"Expected dataset payload to be a dict, got {type(payload)!r}")

    if "x" not in payload:
        raise KeyError("Dataset payload missing 'x' tensor.")

    stack = payload["x"]
    if not isinstance(stack, torch.Tensor):
        raise TypeError(f"Expected 'x' entry to be a torch.Tensor, got {type(stack)!r}")

    count = stack.shape[0]

    def _coerce_sequence(value: Any) -> Optional[List[str]]:
        if value is None:
            return None
        if isinstance(value, torch.Tensor):
            if value.ndim == 1 and value.shape[0] == count:
                return [str(item) for item in value.detach().cpu().tolist()]
            return None
        if isinstance(value, Sequence) and not isinstance(value, (str, bytes)) and len(value) == count:
            return [str(item) for item in value]
        return None

    label_names = _coerce_sequence(payload.get("label_names"))
    if label_names is None:
        label_names = _coerce_sequence(payload.get("labels"))
    if label_names is None:
        label_names = [f"sample_{idx}" for idx in range(count)]

    metadata = [
        StereoPair(base=name, left_path=None, right_path=None)
        for name in label_names
    ]

    meta_info = payload.get("meta", {})
    return stack, metadata, meta_info


def visualize_stereo_pair(
    stack: torch.Tensor,
    index: int,
    metadata: Sequence[StereoPair],
) -> None:
    """
    Display overlap (left=blue, right=red), mirrored, and original right-eye views.
    """
    if stack.ndim != 4 or stack.shape[1] != 2:
        raise ValueError("Expected stack of shape (N, 2, H, W).")

    if not (0 <= index < stack.shape[0]):
        raise IndexError(f"Index {index} out of range for stack of size {stack.shape[0]}.")

    if len(metadata) != stack.shape[0]:
        raise ValueError("Metadata length must match number of stereo pairs.")

    sample = metadata[index]

    left = stack[index, 0].detach().cpu().numpy()
    right_mirrored = stack[index, 1].detach().cpu().numpy()
    right_original = np.fliplr(right_mirrored)

    def tint_blue(channel: np.ndarray) -> np.ndarray:
        colored = np.zeros((*channel.shape, 3), dtype=np.float32)
        colored[..., 2] = channel
        return colored

    def tint_red(channel: np.ndarray) -> np.ndarray:
        colored = np.zeros((*channel.shape, 3), dtype=np.float32)
        colored[..., 0] = channel
        return colored

    overlap = tint_blue(left) + tint_red(right_mirrored)
    overlap = np.clip(overlap, 0.0, 1.0)

    left_vs_mirrored = np.concatenate(
        (tint_blue(left), tint_red(right_mirrored)),
        axis=1,
    )
    left_vs_original = np.concatenate(
        (tint_blue(left), tint_red(right_original)),
        axis=1,
    )

    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    axes[0].imshow(overlap)
    axes[0].set_title("Overlap (Left=Blue, Right=Red)")
    axes[0].axis("off")

    axes[1].imshow(left_vs_mirrored)
    axes[1].set_title("Left vs Right (Mirrored)")
    axes[1].axis("off")

    axes[2].imshow(left_vs_original)
    axes[2].set_title("Left vs Right (Original)")
    axes[2].axis("off")

    fig.suptitle(f"Stereo Pair: {sample.base} (index {index})")
    plt.tight_layout()
    plt.show()


def stereo_pair_display(
    stack: torch.Tensor,
    metadata: Sequence[StereoPair],
    *,
    view_mode: str = "multi",
    direction: Optional[str] = None,
    duplicates_csv: Optional[Union[str, Path]] = None,
) -> None:
    """
    Interactive visualization for stereo image tensors.

    Args:
        stack: Tensor shaped (N, 2, H, W) containing left/right-eye pairs.
        metadata: StereoPair entries corresponding to each tensor.
        view_mode: `"multi"` (default) reproduces the 4×3 grid of views across directions.
            `"single"` shows only one overlap view at a time.
            `"duplicates"` lets you step through groups listed in a duplicate CSV.
        direction: When `view_mode="single"`, sets the initial direction label (e.g. `"N"`).
        duplicates_csv: Optional CSV file containing duplicate rows (only used when `view_mode="duplicates"`).
            Defaults to `data/pt-files/dedup-all-images-dataset.csv`.
    """
    if stack.ndim != 4 or stack.shape[1] != 2:
        raise ValueError("Expected stack of shape (N, 2, H, W).")

    if len(metadata) != stack.shape[0]:
        raise ValueError("Metadata length must match number of stereo pairs.")

    CONFIG_FIELDS = ("session_phase", "start_arm", "cue_wall", "goal_zone")
    CONFIG_RE = re.compile(
        r"""^
            (?P<session_phase>[a-z0-9]+)
            _(?P<start_arm>[a-z0-9]+)
            _(?P<cue_wall>[a-z0-9]+)
            _(?P<goal_zone>[a-z0-9]+)
            _(?P<x>-?\d+)
            _(?P<y>-?\d+)
            _(?P<direction>(?:n|e|s|w|ne|nw|se|sw))
            (?:_(?P<eye>l|r))?
        $""",
        re.IGNORECASE | re.VERBOSE,
    )

    def parse_base(base: str) -> Tuple[str, str, str, str]:
        token = Path(base).stem if "." in base else base
        token = token.strip()
        match = CONFIG_RE.match(token)
        if match:
            prefix = "_".join(match.group(field).lower() for field in CONFIG_FIELDS)
            x = match.group("x")
            y = match.group("y")
            direction = match.group("direction").upper()
            return prefix, x, y, direction

        parts = [part for part in token.split("_") if part]
        if len(parts) < 4:
            raise ValueError(f"Unexpected base format: {base}")
        config = "_".join(parts[:-3]) if len(parts) > 4 else parts[0]
        x = parts[-3]
        y = parts[-2]
        direction = parts[-1].upper()
        return config, x, y, direction

    def tint_blue(channel: np.ndarray) -> np.ndarray:
        colored = np.zeros((*channel.shape, 3), dtype=np.float32)
        colored[..., 2] = channel
        return colored

    def tint_red(channel: np.ndarray) -> np.ndarray:
        colored = np.zeros((*channel.shape, 3), dtype=np.float32)
        colored[..., 0] = channel
        return colored

    def resize_axis(ax, width_px: float, height_px: float) -> None:
        """Resize an Axes to a specific pixel size while keeping it centered over its original slot."""
        fig = ax.figure
        fig_w, fig_h = fig.get_size_inches()
        width = width_px / (fig_w * fig.dpi)
        height = height_px / (fig_h * fig.dpi)
        bbox = ax.get_position()
        cx = bbox.x0 + bbox.width / 2
        y0 = bbox.y0 + (bbox.height - height) / 2
        x0 = cx - width / 2
        ax.set_position([x0, y0, width, height])

    position_map: Dict[Tuple[str, str, str], Dict[str, Tuple[np.ndarray, np.ndarray, np.ndarray, str]]] = defaultdict(dict)
    position_sets: Dict[str, set[Tuple[str, str]]] = defaultdict(set)

    for idx, sample in enumerate(metadata):
        full_label = sample.base
        config, x, y, direction = parse_base(full_label)
        left = stack[idx, 0].detach().cpu().numpy()
        right_mirrored = stack[idx, 1].detach().cpu().numpy()
        right_original = np.fliplr(right_mirrored)
        position_map[(config, x, y)][direction] = (left, right_mirrored, right_original, full_label)
        position_sets[config].add((x, y))

    if not position_map:
        raise RuntimeError("No stereo pairs available to visualize." )

    direction_preference = ["N", "E", "S", "W", "NE", "NW", "SE", "SW"]

    positions_by_config = {
        cfg: sorted(pos_set)
        for cfg, pos_set in position_sets.items()
        if pos_set
    }
    configs = sorted(positions_by_config.keys())
    if not configs:
        raise RuntimeError("No valid config/position combinations available.")

    mode = view_mode.lower()
    if mode not in {"multi", "single", "duplicates"}:
        raise ValueError(f"Unsupported view_mode {view_mode!r}. Use 'multi', 'single', or 'duplicates'.")

    if mode == "single":
        position_indices = {cfg: 0 for cfg in configs}
        direction_indices: Dict[Tuple[str, str, str], int] = {
            key: 0 for key in position_map.keys()
        }
        current_config_idx = 0
        is_updating = False
        initial_direction = direction.upper() if direction else None
        initial_direction_consumed = False

        fig = plt.figure(figsize=(8, 6), constrained_layout=False, facecolor="#151515")
        top_margin = 5.0 / (fig.get_size_inches()[1] * fig.dpi)
        fig.subplots_adjust(top=1.0 - top_margin)
        outer_grid = fig.add_gridspec(
            nrows=2,
            ncols=3,
            height_ratios=[0.12, 0.88],
            hspace=0.25,
            wspace=0.15,
        )

        controls_grid = outer_grid[0, :].subgridspec(
            1,
            3,
            width_ratios=[0.3, 0.3, 0.4],
            wspace=0.2,
        )

        config_grid = controls_grid[0, 0].subgridspec(1, 3, width_ratios=[0.25, 0.5, 0.25])
        position_grid = controls_grid[0, 1].subgridspec(1, 3, width_ratios=[0.25, 0.5, 0.25])
        direction_grid = controls_grid[0, 2].subgridspec(1, 3, width_ratios=[0.25, 0.5, 0.25])

        config_prev_ax = fig.add_subplot(config_grid[0, 0])
        config_box_ax = fig.add_subplot(config_grid[0, 1])
        config_next_ax = fig.add_subplot(config_grid[0, 2])

        position_prev_ax = fig.add_subplot(position_grid[0, 0])
        position_box_ax = fig.add_subplot(position_grid[0, 1])
        position_next_ax = fig.add_subplot(position_grid[0, 2])

        direction_prev_ax = fig.add_subplot(direction_grid[0, 0])
        direction_box_ax = fig.add_subplot(direction_grid[0, 1])
        direction_next_ax = fig.add_subplot(direction_grid[0, 2])

        image_ax = fig.add_subplot(outer_grid[1, :])

        def style_axis(ax) -> None:
            ax.set_xticks([])
            ax.set_yticks([])
            ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)
            ax.set_frame_on(True)
            ax.set_facecolor("#151515")
            for spine in ax.spines.values():
                spine.set_edgecolor("#7f7f7f")
                spine.set_linewidth(1.0)

        for ax in (
            config_prev_ax,
            config_box_ax,
            config_next_ax,
            position_prev_ax,
            position_box_ax,
            position_next_ax,
            direction_prev_ax,
            direction_box_ax,
            direction_next_ax,
        ):
            ax.set_xticks([])
            ax.set_yticks([])

        for ax in (
            config_prev_ax,
            config_next_ax,
            position_prev_ax,
            position_next_ax,
            direction_prev_ax,
            direction_next_ax,
        ):
            resize_axis(ax, width_px=34, height_px=22)

        for ax in (config_box_ax, position_box_ax, direction_box_ax):
            resize_axis(ax, width_px=110, height_px=22)

        config_box = TextBox(config_box_ax, "Config", initial="", color="#ffffff", hovercolor="#dddddd")
        position_box = TextBox(position_box_ax, "Position (x,y)", initial="", color="#ffffff", hovercolor="#dddddd")
        direction_box = TextBox(direction_box_ax, "Direction", initial=direction or "", color="#ffffff", hovercolor="#dddddd")

        for ax in (config_box_ax, position_box_ax, direction_box_ax):
            ax.set_facecolor("#ffffff")

        for ax in (
            config_prev_ax,
            config_next_ax,
            position_prev_ax,
            position_next_ax,
            direction_prev_ax,
            direction_next_ax,
        ):
            ax.set_facecolor("#f0f0f0")

        config_prev_btn = Button(config_prev_ax, "←")
        config_next_btn = Button(config_next_ax, "→")
        position_prev_btn = Button(position_prev_ax, "←")
        position_next_btn = Button(position_next_ax, "→")
        direction_prev_btn = Button(direction_prev_ax, "←")
        direction_next_btn = Button(direction_next_ax, "→")

        for btn in (
            config_prev_btn,
            config_next_btn,
            position_prev_btn,
            position_next_btn,
            direction_prev_btn,
            direction_next_btn,
        ):
            btn.label.set_fontsize(9)
            btn.label.set_color("#000000")

        config_box.text_disp.set_color("#000000")
        position_box.text_disp.set_color("#000000")
        direction_box.text_disp.set_color("#000000")
        for tb in (config_box, position_box, direction_box):
            tb.text_disp.set_fontsize(10)
            tb.label.set_color("#ffffff")
            tb.label.set_fontsize(9)
            tb.label.set_position((0.5, 1.1))
            tb.label.set_horizontalalignment("center")
            tb.label.set_verticalalignment("bottom")

        style_axis(image_ax)

        alias_map = {
            "north": "N",
            "south": "S",
            "east": "E",
            "west": "W",
            "northeast": "NE",
            "northwest": "NW",
            "southeast": "SE",
            "southwest": "SW",
        }

        def show_message(message: str) -> None:
            image_ax.cla()
            style_axis(image_ax)
            image_ax.text(
                0.5,
                0.5,
                message,
                ha="center",
                va="center",
                fontsize=12,
                color="#e0e0e0",
            )

        def ordered_directions(
            direction_dict: Dict[str, Tuple[np.ndarray, np.ndarray, np.ndarray, str]]
        ) -> List[str]:
            ordered = [d for d in direction_preference if d in direction_dict]
            remaining = sorted(set(direction_dict.keys()) - set(ordered))
            return ordered + remaining

        def available_directions(key: Tuple[str, str, str]) -> List[str]:
            direction_dict = position_map.get(key, {})
            return ordered_directions(direction_dict)

        def render_direction(
            cfg: str,
            x_val: str,
            y_val: str,
            dir_label: str,
        ) -> None:
            key = (cfg, x_val, y_val)
            direction_dict = position_map[key]
            left, right_mirrored, _, full_label = direction_dict[dir_label]
            overlap = np.clip(tint_blue(left) + tint_red(right_mirrored), 0.0, 1.0)

            image_ax.imshow(overlap)
            image_ax.set_title(
                f"{cfg} / ({x_val},{y_val}) / {dir_label}\n{full_label}",
                fontsize=12,
                color="#dcdcdc",
            )

        def update_display(_: str) -> None:
            nonlocal current_config_idx, is_updating, initial_direction_consumed
            if is_updating:
                return
            is_updating = True

            cfg = config_box.text.strip()
            pos_text = position_box.text.strip()
            dir_text = direction_box.text.strip()

            if cfg not in positions_by_config:
                show_message("Config not available.")
                is_updating = False
                fig.canvas.draw_idle()
                return

            positions = positions_by_config[cfg]
            if not positions:
                show_message("No positions recorded for this config.")
                is_updating = False
                fig.canvas.draw_idle()
                return

            current_config_idx = configs.index(cfg)

            if "," in pos_text:
                parts = [p.strip() for p in pos_text.split(",", 1)]
            else:
                parts = [p.strip() for p in pos_text.split() if p.strip()]

            if len(parts) == 2:
                x_val, y_val = parts
            else:
                x_val = y_val = None

            key = (cfg, x_val, y_val) if x_val is not None and y_val is not None else None
            if key is None or key not in position_map:
                default_idx = position_indices[cfg] % len(positions)
                x_val, y_val = positions[default_idx]
                is_updating = False
                position_box.set_val(f"{x_val},{y_val}")
                return

            pos_index = positions.index((x_val, y_val))
            position_indices[cfg] = pos_index

            direction_options = available_directions((cfg, x_val, y_val))
            if not direction_options:
                show_message("No directions available for this position.")
                is_updating = False
                fig.canvas.draw_idle()
                return

            lookup = {d.upper(): d for d in direction_options}
            for label in direction_options:
                alias = alias_map.get(label.lower())
                if alias:
                    lookup[alias.upper()] = label

            chosen = None
            if dir_text:
                if dir_text in direction_options:
                    chosen = dir_text
                else:
                    chosen = lookup.get(dir_text.upper())
            if chosen is None and not initial_direction_consumed and initial_direction:
                chosen = lookup.get(initial_direction)
            if chosen is None:
                idx = direction_indices[(cfg, x_val, y_val)] % len(direction_options)
                chosen = direction_options[idx]

            direction_indices[(cfg, x_val, y_val)] = direction_options.index(chosen)
            initial_direction_consumed = True

            if dir_text != chosen:
                direction_box.set_val(chosen)
                is_updating = False
                return

            image_ax.cla()
            style_axis(image_ax)
            render_direction(cfg, x_val, y_val, chosen)
            label_text = position_map[(cfg, x_val, y_val)][chosen][3]
            image_ax.text(
                0.02,
                0.02,
                f"Config: {cfg} | Position: ({x_val}, {y_val}) | Direction: {chosen}\nLabel: {label_text}",
                va="bottom",
                ha="left",
                fontsize=12,
                color="#e0e0e0",
                transform=image_ax.transAxes,
            )

            is_updating = False
            fig.canvas.draw_idle()

        def set_config(new_index: int) -> None:
            nonlocal current_config_idx, is_updating
            if not configs:
                return
            new_index %= len(configs)
            cfg = configs[new_index]
            positions = positions_by_config[cfg]
            if not positions:
                show_message("No positions recorded for this config.")
                return

            current_config_idx = new_index
            pos_idx = position_indices[cfg] % len(positions)
            pos = positions[pos_idx]

            is_updating = True
            config_box.set_val(cfg)
            position_box.set_val(f"{pos[0]},{pos[1]}")
            is_updating = False
            update_display("")

        def shift_position(delta: int) -> None:
            nonlocal is_updating
            cfg = configs[current_config_idx]
            positions = positions_by_config[cfg]
            if not positions:
                return
            new_index = (position_indices[cfg] + delta) % len(positions)
            position_indices[cfg] = new_index
            x_val, y_val = positions[new_index]

            is_updating = True
            position_box.set_val(f"{x_val},{y_val}")
            is_updating = False
            update_display("")

        def shift_direction(delta: int) -> None:
            nonlocal is_updating
            cfg = config_box.text.strip()
            pos_text = position_box.text.strip()
            if cfg not in positions_by_config:
                return
            if "," in pos_text:
                parts = [p.strip() for p in pos_text.split(",", 1)]
            else:
                parts = [p.strip() for p in pos_text.split() if p.strip()]
            if len(parts) != 2:
                return
            x_val, y_val = parts
            key = (cfg, x_val, y_val)
            if key not in position_map:
                return
            options = available_directions(key)
            if not options:
                return
            new_index = (direction_indices[key] + delta) % len(options)
            direction_indices[key] = new_index
            is_updating = True
            direction_box.set_val(options[new_index])
            is_updating = False
            update_display("")

        config_box.on_submit(update_display)
        position_box.on_submit(update_display)
        direction_box.on_submit(update_display)

        config_prev_btn.on_clicked(lambda _: set_config(current_config_idx - 1))
        config_next_btn.on_clicked(lambda _: set_config(current_config_idx + 1))
        position_prev_btn.on_clicked(lambda _: shift_position(-1))
        position_next_btn.on_clicked(lambda _: shift_position(1))
        direction_prev_btn.on_clicked(lambda _: shift_direction(-1))
        direction_next_btn.on_clicked(lambda _: shift_direction(1))

        set_config(0)
        plt.show()
        return
    elif mode == "duplicates":
        csv_path = Path(duplicates_csv or DEFAULT_DUPLICATE_CSV).expanduser()
        if not csv_path.exists():
            raise FileNotFoundError(f"Duplicate CSV not found: {csv_path}")

        def _load_duplicate_rows(path: Path) -> List[List[str]]:
            groups: List[List[str]] = []
            with path.open("r", encoding="utf-8") as fh:
                for line in fh:
                    tokens = [token.strip() for token in line.strip().split(",") if token.strip()]
                    if tokens:
                        groups.append(tokens)
            return groups

        raw_groups = _load_duplicate_rows(csv_path)
        label_to_index = {sample.base: idx for idx, sample in enumerate(metadata)}
        duplicate_groups: List[List[str]] = []
        skipped_groups = 0
        for row in raw_groups:
            filtered = [label for label in row if label in label_to_index]
            if filtered:
                duplicate_groups.append(filtered)
            else:
                skipped_groups += 1

        if not duplicate_groups:
            raise RuntimeError(
                f"No duplicate groups matched dataset labels. Rows skipped: {skipped_groups}"
            )

        group_idx = 0
        member_idx = 0

        fig = plt.figure(figsize=(13.5, 10.5), constrained_layout=False, facecolor="#151515")
        outer_grid = fig.add_gridspec(
            nrows=2,
            ncols=2,
            height_ratios=[0.4, 0.6],
            width_ratios=[0.3, 0.7],
            hspace=0.2,
            wspace=0.25,
        )

        info_ax = fig.add_subplot(outer_grid[0, 0])
        info_ax.axis("off")
        info_text = info_ax.text(
            0.0,
            0.5,
            "",
            va="center",
            ha="left",
            fontsize=11,
            color="#e0e0e0",
        )

        def style_axis(ax) -> None:
            ax.set_xticks([])
            ax.set_yticks([])
            ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)
            ax.set_frame_on(True)
            ax.set_facecolor("#151515")
            for spine in ax.spines.values():
                spine.set_edgecolor("#7f7f7f")
                spine.set_linewidth(1.0)

        button_grid = outer_grid[1, 0].subgridspec(4, 1, hspace=0.2)
        group_prev_ax = fig.add_subplot(button_grid[0, 0])
        group_next_ax = fig.add_subplot(button_grid[1, 0])
        item_prev_ax = fig.add_subplot(button_grid[2, 0])
        item_next_ax = fig.add_subplot(button_grid[3, 0])
        for ax in (group_prev_ax, group_next_ax, item_prev_ax, item_next_ax):
            ax.set_xticks([])
            ax.set_yticks([])
            ax.set_facecolor("#f0f0f0")
            resize_axis(ax, width_px=80, height_px=30)

        group_prev_btn = Button(group_prev_ax, "Prev Group")
        group_next_btn = Button(group_next_ax, "Next Group")
        item_prev_btn = Button(item_prev_ax, "Prev Item")
        item_next_btn = Button(item_next_ax, "Next Item")
        for btn in (group_prev_btn, group_next_btn, item_prev_btn, item_next_btn):
            btn.label.set_fontsize(9)
            btn.label.set_color("#000000")

        image_ax = fig.add_subplot(outer_grid[:, 1])
        style_axis(image_ax)

        def _fetch_label_images(label: str) -> Tuple[np.ndarray, np.ndarray]:
            idx = label_to_index[label]
            left = stack[idx, 0].detach().cpu().numpy()
            right_mirrored = stack[idx, 1].detach().cpu().numpy()
            return left, right_mirrored

        def render_duplicate_view(label: str) -> None:
            left, right_mirrored = _fetch_label_images(label)
            overlap = np.clip(tint_blue(left) + tint_red(right_mirrored), 0.0, 1.0)

            image_ax.cla()
            style_axis(image_ax)
            image_ax.imshow(overlap)
            image_ax.set_title("Overlap (Left=Blue, Right=Red)", fontsize=12, color="#dcdcdc")

        def update_duplicate_display() -> None:
            group = duplicate_groups[group_idx]
            label = group[member_idx]
            render_duplicate_view(label)
            info_text.set_text(
                f"Group {group_idx + 1}/{len(duplicate_groups)} "
                f"(size {len(group)}) | Item {member_idx + 1}/{len(group)}\n{label}"
            )
            fig.canvas.draw_idle()

        def shift_group(delta: int) -> None:
            nonlocal group_idx, member_idx
            total = len(duplicate_groups)
            group_idx = (group_idx + delta) % total
            member_idx = 0
            update_duplicate_display()

        def shift_member(delta: int) -> None:
            nonlocal member_idx
            group = duplicate_groups[group_idx]
            member_idx = (member_idx + delta) % len(group)
            update_duplicate_display()

        group_prev_btn.on_clicked(lambda _: shift_group(-1))
        group_next_btn.on_clicked(lambda _: shift_group(1))
        item_prev_btn.on_clicked(lambda _: shift_member(-1))
        item_next_btn.on_clicked(lambda _: shift_member(1))

        update_duplicate_display()
        plt.show()
        return

    position_indices = {cfg: 0 for cfg in configs}
    current_config_idx = 0
    is_updating = False

    fig = plt.figure(figsize=(10, 8), constrained_layout=False, facecolor="#151515")
    top_margin = 5.0 / (fig.get_size_inches()[1] * fig.dpi)
    fig.subplots_adjust(top=1.0 - top_margin)
    outer_grid = fig.add_gridspec(
        nrows=5,
        ncols=3,
        height_ratios=[0.15, 1, 1, 1, 1],
        hspace=0.3,
        wspace=0.2,
    )

    controls_grid = outer_grid[0, :].subgridspec(
        1,
        3,
        width_ratios=[0.3, 0.3, 0.4],
        wspace=0.2,
    )

    config_grid = controls_grid[0, 0].subgridspec(1, 3, width_ratios=[0.3, 0.4, 0.3])
    position_grid = controls_grid[0, 1].subgridspec(1, 3, width_ratios=[0.3, 0.4, 0.3])

    config_prev_ax = fig.add_subplot(config_grid[0, 0])
    config_box_ax = fig.add_subplot(config_grid[0, 2])
    config_next_ax = fig.add_subplot(config_grid[0, 1])

    position_prev_ax = fig.add_subplot(position_grid[0, 0])
    position_box_ax = fig.add_subplot(position_grid[0, 2])
    position_next_ax = fig.add_subplot(position_grid[0, 1])

    info_ax = fig.add_subplot(controls_grid[0, 2])
    info_ax.axis("off")
    info_text = info_ax.text(0.0, 0.5, "", va="center", ha="left", fontsize=12, color="#e0e0e0")

    for ax in (
        config_prev_ax,
        config_box_ax,
        config_next_ax,
        position_prev_ax,
        position_box_ax,
        position_next_ax,
    ):
        ax.set_xticks([])
        ax.set_yticks([])

    for ax in (config_prev_ax, config_next_ax, position_prev_ax, position_next_ax):
        resize_axis(ax, width_px=34, height_px=22)

    for ax in (config_box_ax, position_box_ax):
        resize_axis(ax, width_px=110, height_px=22)

    config_box = TextBox(config_box_ax, "Config", initial="", color="#ffffff", hovercolor="#dddddd")
    position_box = TextBox(position_box_ax, "Position (x,y)", initial="", color="#ffffff", hovercolor="#dddddd")
    for ax in (config_box_ax, position_box_ax):
        ax.set_facecolor("#ffffff")

    for ax in (config_prev_ax, config_next_ax, position_prev_ax, position_next_ax):
        ax.set_facecolor("#f0f0f0")

    config_prev_btn = Button(config_prev_ax, "←")
    config_next_btn = Button(config_next_ax, "→")
    position_prev_btn = Button(position_prev_ax, "←")
    position_next_btn = Button(position_next_ax, "→")

    for btn in (
        config_prev_btn,
        config_next_btn,
        position_prev_btn,
        position_next_btn,
    ):
        btn.label.set_fontsize(9)
        btn.label.set_color("#000000")

    config_box.text_disp.set_color("#000000")
    position_box.text_disp.set_color("#000000")
    for tb in (config_box, position_box):
        tb.text_disp.set_fontsize(10)
        tb.label.set_color("#ffffff")
        tb.label.set_fontsize(9)
        tb.label.set_position((0.5, 1.1))
        tb.label.set_horizontalalignment("center")
        tb.label.set_verticalalignment("bottom")

    def style_axis(ax) -> None:
        ax.set_xticks([])
        ax.set_yticks([])
        ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)
        ax.set_frame_on(True)
        ax.set_facecolor("#151515")
        for spine in ax.spines.values():
            spine.set_edgecolor("#7f7f7f")
            spine.set_linewidth(1.0)

    axes = np.empty((4, 3), dtype=object)
    for row in range(4):
        for col in range(3):
            axes[row, col] = fig.add_subplot(outer_grid[row + 1, col])
            style_axis(axes[row, col])

    column_titles = [
        "Overlap (Left=Blue, Right=Red)",
        "Left vs Right (Mirrored)",
        "Left vs Right (Original)",
    ]

    def preferred_directions(direction_dict: Dict[str, Tuple[np.ndarray, np.ndarray, np.ndarray, str]]) -> List[str]:
        ordered = [d for d in direction_preference if d in direction_dict]
        remaining = sorted(set(direction_dict.keys()) - set(ordered))
        return (ordered + remaining)[:4]

    def clear_panels() -> None:
        for row in range(4):
            for col in range(3):
                axes[row, col].cla()
                style_axis(axes[row, col])

    def update_display(_: str) -> None:
        nonlocal current_config_idx, is_updating
        if is_updating:
            return
        is_updating = True

        cfg = config_box.text.strip()
        pos_text = position_box.text.strip()

        if cfg not in positions_by_config:
            info_text.set_text("Config not available.")
            clear_panels()
            is_updating = False
            fig.canvas.draw_idle()
            return

        positions = positions_by_config[cfg]
        if not positions:
            info_text.set_text("No positions recorded for this config.")
            clear_panels()
            is_updating = False
            fig.canvas.draw_idle()
            return

        current_config_idx = configs.index(cfg)

        if "," in pos_text:
            parts = [p.strip() for p in pos_text.split(",", 1)]
        else:
            parts = [p.strip() for p in pos_text.split() if p.strip()]

        if len(parts) == 2:
            x_val, y_val = parts
        else:
            x_val = y_val = None

        key = (cfg, x_val, y_val) if x_val is not None and y_val is not None else None
        if key is None or key not in position_map:
            default_idx = position_indices[cfg] % len(positions)
            x_val, y_val = positions[default_idx]
            is_updating = False
            position_box.set_val(f"{x_val},{y_val}")
            return

        pos_index = positions.index((x_val, y_val))
        position_indices[cfg] = pos_index

        direction_dict = position_map.get(key)
        if not direction_dict:
            info_text.set_text("Directions not available for selection.")
            clear_panels()
            is_updating = False
            fig.canvas.draw_idle()
            return

        label_summary = "\n".join(
            f"{dir_label}: {direction_dict[dir_label][3]}"
            for dir_label in preferred_directions(direction_dict)
        )
        info_text.set_text(f"Config: {cfg} | Position: ({x_val}, {y_val})\n{label_summary}")
        clear_panels()

        for col, title in enumerate(column_titles):
            axes[0, col].set_title(title, fontsize=12, pad=10, color="#dcdcdc")

        directions_to_show = preferred_directions(direction_dict)
        for row_idx in range(4):
            if row_idx < len(directions_to_show):
                direction = directions_to_show[row_idx]
                left, right_mirrored, right_original, full_label = direction_dict[direction]

                overlap = np.clip(tint_blue(left) + tint_red(right_mirrored), 0.0, 1.0)
                left_vs_mirrored = np.concatenate(
                    (tint_blue(left), tint_red(right_mirrored)),
                    axis=1,
                )
                left_vs_original = np.concatenate(
                    (tint_blue(left), tint_red(right_original)),
                    axis=1,
                )

                axes[row_idx, 0].imshow(overlap)
                axes[row_idx, 1].imshow(left_vs_mirrored)
                axes[row_idx, 2].imshow(left_vs_original)

                for col in range(3):
                    style_axis(axes[row_idx, col])

                axes[row_idx, 0].text(
                    -0.12,
                    0.5,
                    direction,
                    transform=axes[row_idx, 0].transAxes,
                    rotation=90,
                    va="center",
                    ha="center",
                    fontsize=10,
                    fontweight="bold",
                    color="#dcdcdc",
                )

                axes[row_idx, 0].text(
                    0.02,
                    0.93,
                    full_label,
                    transform=axes[row_idx, 0].transAxes,
                    va="top",
                    ha="left",
                    fontsize=8,
                    color="#f0f0f0",
                    bbox={
                        "facecolor": "#00000060",
                        "edgecolor": "none",
                        "boxstyle": "round,pad=0.2",
                    },
                )

                for col in range(3):
                    style_axis(axes[row_idx, col])
            else:
                for col in range(3):
                    axes[row_idx, col].text(
                        0.5,
                        0.5,
                        "Image not available",
                        ha="center",
                        va="center",
                        fontsize=9,
                    )
                    style_axis(axes[row_idx, col])

        is_updating = False
        fig.canvas.draw_idle()

    def set_config(new_index: int) -> None:
        nonlocal current_config_idx, is_updating
        if not configs:
            return
        new_index %= len(configs)
        cfg = configs[new_index]
        positions = positions_by_config[cfg]
        if not positions:
            info_text.set_text("No positions recorded for this config.")
            clear_panels()
            return

        current_config_idx = new_index
        pos_idx = position_indices[cfg] % len(positions)
        pos = positions[pos_idx]

        is_updating = True
        config_box.set_val(cfg)
        position_box.set_val(f"{pos[0]},{pos[1]}")
        is_updating = False
        update_display("")

    def shift_position(delta: int) -> None:
        nonlocal is_updating
        if not configs:
            return
        cfg = configs[current_config_idx]
        positions = positions_by_config[cfg]
        if not positions:
            return
        new_index = (position_indices[cfg] + delta) % len(positions)
        position_indices[cfg] = new_index
        x_val, y_val = positions[new_index]

        is_updating = True
        position_box.set_val(f"{x_val},{y_val}")
        is_updating = False
        update_display("")

    config_box.on_submit(update_display)
    position_box.on_submit(update_display)

    config_prev_btn.on_clicked(lambda _: set_config(current_config_idx - 1))
    config_next_btn.on_clicked(lambda _: set_config(current_config_idx + 1))
    position_prev_btn.on_clicked(lambda _: shift_position(-1))
    position_next_btn.on_clicked(lambda _: shift_position(1))

    set_config(0)
    plt.show()


def group_similar_stereo_pairs(
    stack: torch.Tensor,
    metadata: Sequence[StereoPair],
    include_singletons: bool = False,
    per_channel_tolerance: float = 0.0,
    mean_tolerance: float = 0.0,
) -> List[List[str]]:
    """
    Group stereo tensors that match within configurable tolerances (png_compare-style).

    Args:
        stack: Tensor shaped (N, 2, H, W) containing left/right-eye pairs.
        metadata: StereoPair entries corresponding to each tensor in the stack.
        include_singletons: If True, include groups with only one element.
        per_channel_tolerance: Maximum allowed absolute per-pixel/channel difference.
            Values > 1 are interpreted on a 0-255 scale (mirroring png_compare).
            Set negative to skip the per-channel threshold.
        mean_tolerance: Maximum allowed mean absolute difference per pixel/channel.
            Values > 1 are interpreted on a 0-255 scale. Set negative to skip.

    Returns:
        A list of groups, where each group is the list of StereoPair.base identifiers
        whose tensors are considered duplicates within the provided tolerances.
    """
    if stack.ndim != 4 or stack.shape[1] != 2:
        raise ValueError("Expected stack with shape (N, 2, H, W).")
    if len(metadata) != stack.shape[0]:
        raise ValueError("Metadata length must match number of stereo pairs.")

    def _normalize_tolerance(value: float) -> float:
        if value < 0:
            return value
        if value > 1.0:
            return value / 255.0
        return value

    per_tol = _normalize_tolerance(per_channel_tolerance)
    mean_tol = _normalize_tolerance(mean_tolerance)

    tensors = stack.detach().cpu()

    def _pairs_similar(idx_a: int, idx_b: int) -> bool:
        diff = torch.abs(tensors[idx_a] - tensors[idx_b])
        max_diff = diff.max().item()
        mean_diff = diff.mean().item()

        if per_tol < 0 and mean_tol < 0:
            return max_diff == 0.0

        if per_tol >= 0 and max_diff > per_tol:
            return False
        if mean_tol >= 0 and mean_diff > mean_tol:
            return False
        return True

    size = tensors.shape[0]
    parent = list(range(size))

    def find(x: int) -> int:
        while parent[x] != x:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x

    def union(a: int, b: int) -> None:
        root_a, root_b = find(a), find(b)
        if root_a == root_b:
            return
        parent[root_b] = root_a

    for i in range(size):
        for j in range(i + 1, size):
            if _pairs_similar(i, j):
                union(i, j)

    clusters: Dict[int, List[int]] = {}
    for idx in range(size):
        root = find(idx)
        clusters.setdefault(root, []).append(idx)

    name_groups: List[List[str]] = []
    for indices in clusters.values():
        if include_singletons or len(indices) > 1:
            names = [metadata[i].base for i in indices]
            name_groups.append(sorted(names))

    name_groups.sort(key=lambda items: (-len(items), items[0]))
    return name_groups


if __name__ == "__main__":
    bundle_path = Path(DEFAULT_DATASET_BUNDLE)
    stack, metadata, meta_info = load_dataset_bundle(bundle_path)
    print(f"Loaded dataset from {bundle_path.expanduser().resolve()}")
    print("Image stack shape:", tuple(stack.shape))
    if meta_info:
        print(f"Bundle meta: {meta_info}")
    stereo_pair_display(stack, metadata, view_mode='duplicates', direction='N')
    
    # similar_pairs = group_similar_stereo_pairs(stack, metadata, 10, 0.5)
    # for group in similar_pairs:
    #     print(group)
