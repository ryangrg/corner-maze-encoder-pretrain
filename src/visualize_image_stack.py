from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union

import matplotlib.pyplot as plt
import numpy as np
import torch
from matplotlib.widgets import Button, TextBox


@dataclass(frozen=True)
class StereoPair:
    base: str
    left_path: Optional[Path]
    right_path: Optional[Path]


def load_dataset_bundle(
    bundle_path: Path,
    map_location: Union[str, torch.device] = "cpu",
) -> Tuple[torch.Tensor, List[StereoPair], Dict[str, Any]]:
    """
    Load a serialized dataset generated by create_dataset.py.

    Args:
        bundle_path: Path to the .pt file containing the dataset payload.
        map_location: Device specification passed to torch.load.

    Returns:
        A tuple of (tensor stack, metadata list, meta dictionary).
    """
    resolved_path = bundle_path.expanduser().resolve()
    if not resolved_path.exists():
        raise FileNotFoundError(f"Dataset file not found: {resolved_path}")

    payload = torch.load(resolved_path, map_location=map_location)
    if not isinstance(payload, dict):
        raise TypeError(f"Expected dataset payload to be a dict, got {type(payload)!r}")

    if "x" not in payload:
        raise KeyError("Dataset payload missing 'x' tensor.")

    stack = payload["x"]
    if not isinstance(stack, torch.Tensor):
        raise TypeError(f"Expected 'x' entry to be a torch.Tensor, got {type(stack)!r}")

    labels = payload.get("labels")
    if labels is None:
        labels = [f"sample_{idx}" for idx in range(stack.shape[0])]

    metadata = [
        StereoPair(base=str(label), left_path=None, right_path=None)
        for label in labels
    ]

    if len(metadata) != stack.shape[0]:
        raise ValueError(
            f"Label count ({len(metadata)}) does not match tensor length ({stack.shape[0]})."
        )

    meta_info = payload.get("meta", {})
    return stack, metadata, meta_info


def visualize_stereo_pair(
    stack: torch.Tensor,
    index: int,
    metadata: Sequence[StereoPair],
) -> None:
    """
    Display overlap (left=blue, right=red), mirrored, and original right-eye views.
    """
    if stack.ndim != 4 or stack.shape[1] != 2:
        raise ValueError("Expected stack of shape (N, 2, H, W).")

    if not (0 <= index < stack.shape[0]):
        raise IndexError(f"Index {index} out of range for stack of size {stack.shape[0]}.")

    if len(metadata) != stack.shape[0]:
        raise ValueError("Metadata length must match number of stereo pairs.")

    sample = metadata[index]

    left = stack[index, 0].detach().cpu().numpy()
    right_mirrored = stack[index, 1].detach().cpu().numpy()
    right_original = np.fliplr(right_mirrored)

    def tint_blue(channel: np.ndarray) -> np.ndarray:
        colored = np.zeros((*channel.shape, 3), dtype=np.float32)
        colored[..., 2] = channel
        return colored

    def tint_red(channel: np.ndarray) -> np.ndarray:
        colored = np.zeros((*channel.shape, 3), dtype=np.float32)
        colored[..., 0] = channel
        return colored

    overlap = tint_blue(left) + tint_red(right_mirrored)
    overlap = np.clip(overlap, 0.0, 1.0)

    left_vs_mirrored = np.concatenate(
        (tint_blue(left), tint_red(right_mirrored)),
        axis=1,
    )
    left_vs_original = np.concatenate(
        (tint_blue(left), tint_red(right_original)),
        axis=1,
    )

    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    axes[0].imshow(overlap)
    axes[0].set_title("Overlap (Left=Blue, Right=Red)")
    axes[0].axis("off")

    axes[1].imshow(left_vs_mirrored)
    axes[1].set_title("Left vs Right (Mirrored)")
    axes[1].axis("off")

    axes[2].imshow(left_vs_original)
    axes[2].set_title("Left vs Right (Original)")
    axes[2].axis("off")

    fig.suptitle(f"Stereo Pair: {sample.base} (index {index})")
    plt.tight_layout()
    plt.show()


def stereo_pair_display(
    stack: torch.Tensor,
    metadata: Sequence[StereoPair],
    *,
    view_mode: str = "multi",
    direction: Optional[str] = None,
) -> None:
    """
    Interactive visualization for stereo image tensors.

    Args:
        stack: Tensor shaped (N, 2, H, W) containing left/right-eye pairs.
        metadata: StereoPair entries corresponding to each tensor.
        view_mode: `"multi"` (default) reproduces the 4×3 grid of views across directions.
            `"single"` shows only one overlap view at a time.
        direction: When `view_mode="single"`, sets the initial direction label (e.g. `"N"`).
    """
    if stack.ndim != 4 or stack.shape[1] != 2:
        raise ValueError("Expected stack of shape (N, 2, H, W).")

    if len(metadata) != stack.shape[0]:
        raise ValueError("Metadata length must match number of stereo pairs.")

    def parse_base(base: str) -> Tuple[str, str, str, str]:
        parts = base.split("_")
        if len(parts) < 4:
            raise ValueError(f"Unexpected base format: {base}")
        config = parts[0]
        x = parts[1]
        y = parts[2]
        direction = "_".join(parts[3:])
        return config, x, y, direction

    def tint_blue(channel: np.ndarray) -> np.ndarray:
        colored = np.zeros((*channel.shape, 3), dtype=np.float32)
        colored[..., 2] = channel
        return colored

    def tint_red(channel: np.ndarray) -> np.ndarray:
        colored = np.zeros((*channel.shape, 3), dtype=np.float32)
        colored[..., 0] = channel
        return colored

    def resize_axis(ax, width_px: float, height_px: float) -> None:
        """Resize an Axes to a specific pixel size while keeping it centered over its original slot."""
        fig = ax.figure
        fig_w, fig_h = fig.get_size_inches()
        width = width_px / (fig_w * fig.dpi)
        height = height_px / (fig_h * fig.dpi)
        bbox = ax.get_position()
        cx = bbox.x0 + bbox.width / 2
        y0 = bbox.y0 + (bbox.height - height) / 2
        x0 = cx - width / 2
        ax.set_position([x0, y0, width, height])

    position_map: Dict[Tuple[str, str, str], Dict[str, Tuple[np.ndarray, np.ndarray, np.ndarray]]] = defaultdict(dict)
    position_sets: Dict[str, set[Tuple[str, str]]] = defaultdict(set)

    for idx, sample in enumerate(metadata):
        config, x, y, direction = parse_base(sample.base)
        left = stack[idx, 0].detach().cpu().numpy()
        right_mirrored = stack[idx, 1].detach().cpu().numpy()
        right_original = np.fliplr(right_mirrored)
        position_map[(config, x, y)][direction] = (left, right_mirrored, right_original)
        position_sets[config].add((x, y))

    if not position_map:
        raise RuntimeError("No stereo pairs available to visualize." )

    direction_preference = ["N", "E", "S", "W", "NE", "NW", "SE", "SW"]

    positions_by_config = {
        cfg: sorted(pos_set)
        for cfg, pos_set in position_sets.items()
        if pos_set
    }
    configs = sorted(positions_by_config.keys())
    if not configs:
        raise RuntimeError("No valid config/position combinations available.")

    mode = view_mode.lower()
    if mode not in {"multi", "single"}:
        raise ValueError(f"Unsupported view_mode {view_mode!r}. Use 'multi' or 'single'.")

    if mode == "single":
        position_indices = {cfg: 0 for cfg in configs}
        direction_indices: Dict[Tuple[str, str, str], int] = {
            key: 0 for key in position_map.keys()
        }
        current_config_idx = 0
        is_updating = False
        initial_direction = direction.upper() if direction else None
        initial_direction_consumed = False

        fig = plt.figure(figsize=(8, 6), constrained_layout=False, facecolor="#151515")
        top_margin = 5.0 / (fig.get_size_inches()[1] * fig.dpi)
        fig.subplots_adjust(top=1.0 - top_margin)
        outer_grid = fig.add_gridspec(
            nrows=2,
            ncols=3,
            height_ratios=[0.12, 0.88],
            hspace=0.25,
            wspace=0.15,
        )

        controls_grid = outer_grid[0, :].subgridspec(
            1,
            3,
            width_ratios=[0.3, 0.3, 0.4],
            wspace=0.2,
        )

        config_grid = controls_grid[0, 0].subgridspec(1, 3, width_ratios=[0.25, 0.5, 0.25])
        position_grid = controls_grid[0, 1].subgridspec(1, 3, width_ratios=[0.25, 0.5, 0.25])
        direction_grid = controls_grid[0, 2].subgridspec(1, 3, width_ratios=[0.25, 0.5, 0.25])

        config_prev_ax = fig.add_subplot(config_grid[0, 0])
        config_box_ax = fig.add_subplot(config_grid[0, 1])
        config_next_ax = fig.add_subplot(config_grid[0, 2])

        position_prev_ax = fig.add_subplot(position_grid[0, 0])
        position_box_ax = fig.add_subplot(position_grid[0, 1])
        position_next_ax = fig.add_subplot(position_grid[0, 2])

        direction_prev_ax = fig.add_subplot(direction_grid[0, 0])
        direction_box_ax = fig.add_subplot(direction_grid[0, 1])
        direction_next_ax = fig.add_subplot(direction_grid[0, 2])

        image_ax = fig.add_subplot(outer_grid[1, :])

        def style_axis(ax) -> None:
            ax.set_xticks([])
            ax.set_yticks([])
            ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)
            ax.set_frame_on(True)
            ax.set_facecolor("#151515")
            for spine in ax.spines.values():
                spine.set_edgecolor("#7f7f7f")
                spine.set_linewidth(1.0)

        for ax in (
            config_prev_ax,
            config_box_ax,
            config_next_ax,
            position_prev_ax,
            position_box_ax,
            position_next_ax,
            direction_prev_ax,
            direction_box_ax,
            direction_next_ax,
        ):
            ax.set_xticks([])
            ax.set_yticks([])

        for ax in (
            config_prev_ax,
            config_next_ax,
            position_prev_ax,
            position_next_ax,
            direction_prev_ax,
            direction_next_ax,
        ):
            resize_axis(ax, width_px=34, height_px=22)

        for ax in (config_box_ax, position_box_ax, direction_box_ax):
            resize_axis(ax, width_px=110, height_px=22)

        config_box = TextBox(config_box_ax, "Config", initial="", color="#ffffff", hovercolor="#dddddd")
        position_box = TextBox(position_box_ax, "Position (x,y)", initial="", color="#ffffff", hovercolor="#dddddd")
        direction_box = TextBox(direction_box_ax, "Direction", initial=direction or "", color="#ffffff", hovercolor="#dddddd")

        for ax in (config_box_ax, position_box_ax, direction_box_ax):
            ax.set_facecolor("#ffffff")

        for ax in (
            config_prev_ax,
            config_next_ax,
            position_prev_ax,
            position_next_ax,
            direction_prev_ax,
            direction_next_ax,
        ):
            ax.set_facecolor("#f0f0f0")

        config_prev_btn = Button(config_prev_ax, "←")
        config_next_btn = Button(config_next_ax, "→")
        position_prev_btn = Button(position_prev_ax, "←")
        position_next_btn = Button(position_next_ax, "→")
        direction_prev_btn = Button(direction_prev_ax, "←")
        direction_next_btn = Button(direction_next_ax, "→")

        for btn in (
            config_prev_btn,
            config_next_btn,
            position_prev_btn,
            position_next_btn,
            direction_prev_btn,
            direction_next_btn,
        ):
            btn.label.set_fontsize(9)
            btn.label.set_color("#000000")

        config_box.text_disp.set_color("#000000")
        position_box.text_disp.set_color("#000000")
        direction_box.text_disp.set_color("#000000")
        for tb in (config_box, position_box, direction_box):
            tb.text_disp.set_fontsize(10)
            tb.label.set_color("#ffffff")
            tb.label.set_fontsize(9)
            tb.label.set_position((0.5, 1.1))
            tb.label.set_horizontalalignment("center")
            tb.label.set_verticalalignment("bottom")

        style_axis(image_ax)

        alias_map = {
            "north": "N",
            "south": "S",
            "east": "E",
            "west": "W",
            "northeast": "NE",
            "northwest": "NW",
            "southeast": "SE",
            "southwest": "SW",
        }

        def show_message(message: str) -> None:
            image_ax.cla()
            style_axis(image_ax)
            image_ax.text(
                0.5,
                0.5,
                message,
                ha="center",
                va="center",
                fontsize=12,
                color="#e0e0e0",
            )

        def ordered_directions(
            direction_dict: Dict[str, Tuple[np.ndarray, np.ndarray, np.ndarray]]
        ) -> List[str]:
            ordered = [d for d in direction_preference if d in direction_dict]
            remaining = sorted(set(direction_dict.keys()) - set(ordered))
            return ordered + remaining

        def available_directions(key: Tuple[str, str, str]) -> List[str]:
            direction_dict = position_map.get(key, {})
            return ordered_directions(direction_dict)

        def render_direction(
            cfg: str,
            x_val: str,
            y_val: str,
            dir_label: str,
        ) -> None:
            key = (cfg, x_val, y_val)
            direction_dict = position_map[key]
            left, right_mirrored, _ = direction_dict[dir_label]
            overlap = np.clip(tint_blue(left) + tint_red(right_mirrored), 0.0, 1.0)

            image_ax.imshow(overlap)
            image_ax.set_title(
                f"{cfg} / ({x_val},{y_val}) / {dir_label}",
                fontsize=12,
                color="#dcdcdc",
            )

        def update_display(_: str) -> None:
            nonlocal current_config_idx, is_updating, initial_direction_consumed
            if is_updating:
                return
            is_updating = True

            cfg = config_box.text.strip()
            pos_text = position_box.text.strip()
            dir_text = direction_box.text.strip()

            if cfg not in positions_by_config:
                show_message("Config not available.")
                is_updating = False
                fig.canvas.draw_idle()
                return

            positions = positions_by_config[cfg]
            if not positions:
                show_message("No positions recorded for this config.")
                is_updating = False
                fig.canvas.draw_idle()
                return

            current_config_idx = configs.index(cfg)

            if "," in pos_text:
                parts = [p.strip() for p in pos_text.split(",", 1)]
            else:
                parts = [p.strip() for p in pos_text.split() if p.strip()]

            if len(parts) == 2:
                x_val, y_val = parts
            else:
                x_val = y_val = None

            key = (cfg, x_val, y_val) if x_val is not None and y_val is not None else None
            if key is None or key not in position_map:
                default_idx = position_indices[cfg] % len(positions)
                x_val, y_val = positions[default_idx]
                is_updating = False
                position_box.set_val(f"{x_val},{y_val}")
                return

            pos_index = positions.index((x_val, y_val))
            position_indices[cfg] = pos_index

            direction_options = available_directions((cfg, x_val, y_val))
            if not direction_options:
                show_message("No directions available for this position.")
                is_updating = False
                fig.canvas.draw_idle()
                return

            lookup = {d.upper(): d for d in direction_options}
            for label in direction_options:
                alias = alias_map.get(label.lower())
                if alias:
                    lookup[alias.upper()] = label

            chosen = None
            if dir_text:
                if dir_text in direction_options:
                    chosen = dir_text
                else:
                    chosen = lookup.get(dir_text.upper())
            if chosen is None and not initial_direction_consumed and initial_direction:
                chosen = lookup.get(initial_direction)
            if chosen is None:
                idx = direction_indices[(cfg, x_val, y_val)] % len(direction_options)
                chosen = direction_options[idx]

            direction_indices[(cfg, x_val, y_val)] = direction_options.index(chosen)
            initial_direction_consumed = True

            if dir_text != chosen:
                direction_box.set_val(chosen)
                is_updating = False
                return

            image_ax.cla()
            style_axis(image_ax)
            render_direction(cfg, x_val, y_val, chosen)
            image_ax.text(
                0.02,
                0.02,
                f"Config: {cfg} | Position: ({x_val}, {y_val}) | Direction: {chosen}",
                va="bottom",
                ha="left",
                fontsize=12,
                color="#e0e0e0",
                transform=image_ax.transAxes,
            )

            is_updating = False
            fig.canvas.draw_idle()

        def set_config(new_index: int) -> None:
            nonlocal current_config_idx, is_updating
            if not configs:
                return
            new_index %= len(configs)
            cfg = configs[new_index]
            positions = positions_by_config[cfg]
            if not positions:
                show_message("No positions recorded for this config.")
                return

            current_config_idx = new_index
            pos_idx = position_indices[cfg] % len(positions)
            pos = positions[pos_idx]

            is_updating = True
            config_box.set_val(cfg)
            position_box.set_val(f"{pos[0]},{pos[1]}")
            is_updating = False
            update_display("")

        def shift_position(delta: int) -> None:
            nonlocal is_updating
            cfg = configs[current_config_idx]
            positions = positions_by_config[cfg]
            if not positions:
                return
            new_index = (position_indices[cfg] + delta) % len(positions)
            position_indices[cfg] = new_index
            x_val, y_val = positions[new_index]

            is_updating = True
            position_box.set_val(f"{x_val},{y_val}")
            is_updating = False
            update_display("")

        def shift_direction(delta: int) -> None:
            nonlocal is_updating
            cfg = config_box.text.strip()
            pos_text = position_box.text.strip()
            if cfg not in positions_by_config:
                return
            if "," in pos_text:
                parts = [p.strip() for p in pos_text.split(",", 1)]
            else:
                parts = [p.strip() for p in pos_text.split() if p.strip()]
            if len(parts) != 2:
                return
            x_val, y_val = parts
            key = (cfg, x_val, y_val)
            if key not in position_map:
                return
            options = available_directions(key)
            if not options:
                return
            new_index = (direction_indices[key] + delta) % len(options)
            direction_indices[key] = new_index
            is_updating = True
            direction_box.set_val(options[new_index])
            is_updating = False
            update_display("")

        config_box.on_submit(update_display)
        position_box.on_submit(update_display)
        direction_box.on_submit(update_display)

        config_prev_btn.on_clicked(lambda _: set_config(current_config_idx - 1))
        config_next_btn.on_clicked(lambda _: set_config(current_config_idx + 1))
        position_prev_btn.on_clicked(lambda _: shift_position(-1))
        position_next_btn.on_clicked(lambda _: shift_position(1))
        direction_prev_btn.on_clicked(lambda _: shift_direction(-1))
        direction_next_btn.on_clicked(lambda _: shift_direction(1))

        set_config(0)
        plt.show()
        return

    position_indices = {cfg: 0 for cfg in configs}
    current_config_idx = 0
    is_updating = False

    fig = plt.figure(figsize=(10, 8), constrained_layout=False, facecolor="#151515")
    top_margin = 5.0 / (fig.get_size_inches()[1] * fig.dpi)
    fig.subplots_adjust(top=1.0 - top_margin)
    outer_grid = fig.add_gridspec(
        nrows=5,
        ncols=3,
        height_ratios=[0.15, 1, 1, 1, 1],
        hspace=0.3,
        wspace=0.2,
    )

    controls_grid = outer_grid[0, :].subgridspec(
        1,
        3,
        width_ratios=[0.3, 0.3, 0.4],
        wspace=0.2,
    )

    config_grid = controls_grid[0, 0].subgridspec(1, 3, width_ratios=[0.3, 0.4, 0.3])
    position_grid = controls_grid[0, 1].subgridspec(1, 3, width_ratios=[0.3, 0.4, 0.3])

    config_prev_ax = fig.add_subplot(config_grid[0, 0])
    config_box_ax = fig.add_subplot(config_grid[0, 2])
    config_next_ax = fig.add_subplot(config_grid[0, 1])

    position_prev_ax = fig.add_subplot(position_grid[0, 0])
    position_box_ax = fig.add_subplot(position_grid[0, 2])
    position_next_ax = fig.add_subplot(position_grid[0, 1])

    info_ax = fig.add_subplot(controls_grid[0, 2])
    info_ax.axis("off")
    info_text = info_ax.text(0.0, 0.5, "", va="center", ha="left", fontsize=12, color="#e0e0e0")

    for ax in (
        config_prev_ax,
        config_box_ax,
        config_next_ax,
        position_prev_ax,
        position_box_ax,
        position_next_ax,
    ):
        ax.set_xticks([])
        ax.set_yticks([])

    for ax in (config_prev_ax, config_next_ax, position_prev_ax, position_next_ax):
        resize_axis(ax, width_px=34, height_px=22)

    for ax in (config_box_ax, position_box_ax):
        resize_axis(ax, width_px=110, height_px=22)

    config_box = TextBox(config_box_ax, "Config", initial="", color="#ffffff", hovercolor="#dddddd")
    position_box = TextBox(position_box_ax, "Position (x,y)", initial="", color="#ffffff", hovercolor="#dddddd")
    for ax in (config_box_ax, position_box_ax):
        ax.set_facecolor("#ffffff")

    for ax in (config_prev_ax, config_next_ax, position_prev_ax, position_next_ax):
        ax.set_facecolor("#f0f0f0")

    config_prev_btn = Button(config_prev_ax, "←")
    config_next_btn = Button(config_next_ax, "→")
    position_prev_btn = Button(position_prev_ax, "←")
    position_next_btn = Button(position_next_ax, "→")

    for btn in (
        config_prev_btn,
        config_next_btn,
        position_prev_btn,
        position_next_btn,
    ):
        btn.label.set_fontsize(9)
        btn.label.set_color("#000000")

    config_box.text_disp.set_color("#000000")
    position_box.text_disp.set_color("#000000")
    for tb in (config_box, position_box):
        tb.text_disp.set_fontsize(10)
        tb.label.set_color("#ffffff")
        tb.label.set_fontsize(9)
        tb.label.set_position((0.5, 1.1))
        tb.label.set_horizontalalignment("center")
        tb.label.set_verticalalignment("bottom")

    def style_axis(ax) -> None:
        ax.set_xticks([])
        ax.set_yticks([])
        ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)
        ax.set_frame_on(True)
        ax.set_facecolor("#151515")
        for spine in ax.spines.values():
            spine.set_edgecolor("#7f7f7f")
            spine.set_linewidth(1.0)

    axes = np.empty((4, 3), dtype=object)
    for row in range(4):
        for col in range(3):
            axes[row, col] = fig.add_subplot(outer_grid[row + 1, col])
            style_axis(axes[row, col])

    column_titles = [
        "Overlap (Left=Blue, Right=Red)",
        "Left vs Right (Mirrored)",
        "Left vs Right (Original)",
    ]

    def preferred_directions(direction_dict: Dict[str, Tuple[np.ndarray, np.ndarray, np.ndarray]]) -> List[str]:
        ordered = [d for d in direction_preference if d in direction_dict]
        remaining = sorted(set(direction_dict.keys()) - set(ordered))
        return (ordered + remaining)[:4]

    def clear_panels() -> None:
        for row in range(4):
            for col in range(3):
                axes[row, col].cla()
                style_axis(axes[row, col])

    def update_display(_: str) -> None:
        nonlocal current_config_idx, is_updating
        if is_updating:
            return
        is_updating = True

        cfg = config_box.text.strip()
        pos_text = position_box.text.strip()

        if cfg not in positions_by_config:
            info_text.set_text("Config not available.")
            clear_panels()
            is_updating = False
            fig.canvas.draw_idle()
            return

        positions = positions_by_config[cfg]
        if not positions:
            info_text.set_text("No positions recorded for this config.")
            clear_panels()
            is_updating = False
            fig.canvas.draw_idle()
            return

        current_config_idx = configs.index(cfg)

        if "," in pos_text:
            parts = [p.strip() for p in pos_text.split(",", 1)]
        else:
            parts = [p.strip() for p in pos_text.split() if p.strip()]

        if len(parts) == 2:
            x_val, y_val = parts
        else:
            x_val = y_val = None

        key = (cfg, x_val, y_val) if x_val is not None and y_val is not None else None
        if key is None or key not in position_map:
            default_idx = position_indices[cfg] % len(positions)
            x_val, y_val = positions[default_idx]
            is_updating = False
            position_box.set_val(f"{x_val},{y_val}")
            return

        pos_index = positions.index((x_val, y_val))
        position_indices[cfg] = pos_index

        direction_dict = position_map.get(key)
        if not direction_dict:
            info_text.set_text("Directions not available for selection.")
            clear_panels()
            is_updating = False
            fig.canvas.draw_idle()
            return

        info_text.set_text(f"Config: {cfg} | Position: ({x_val}, {y_val})")
        clear_panels()

        for col, title in enumerate(column_titles):
            axes[0, col].set_title(title, fontsize=12, pad=10, color="#dcdcdc")

        directions_to_show = preferred_directions(direction_dict)
        for row_idx in range(4):
            if row_idx < len(directions_to_show):
                direction = directions_to_show[row_idx]
                left, right_mirrored, right_original = direction_dict[direction]

                overlap = np.clip(tint_blue(left) + tint_red(right_mirrored), 0.0, 1.0)
                left_vs_mirrored = np.concatenate(
                    (tint_blue(left), tint_red(right_mirrored)),
                    axis=1,
                )
                left_vs_original = np.concatenate(
                    (tint_blue(left), tint_red(right_original)),
                    axis=1,
                )

                axes[row_idx, 0].imshow(overlap)
                axes[row_idx, 1].imshow(left_vs_mirrored)
                axes[row_idx, 2].imshow(left_vs_original)

                for col in range(3):
                    style_axis(axes[row_idx, col])

                axes[row_idx, 0].text(
                    -0.12,
                    0.5,
                    direction,
                    transform=axes[row_idx, 0].transAxes,
                    rotation=90,
                    va="center",
                    ha="center",
                    fontsize=10,
                    fontweight="bold",
                    color="#dcdcdc",
                )

                for col in range(3):
                    style_axis(axes[row_idx, col])
            else:
                for col in range(3):
                    axes[row_idx, col].text(
                        0.5,
                        0.5,
                        "Image not available",
                        ha="center",
                        va="center",
                        fontsize=9,
                    )
                    style_axis(axes[row_idx, col])

        is_updating = False
        fig.canvas.draw_idle()

    def set_config(new_index: int) -> None:
        nonlocal current_config_idx, is_updating
        if not configs:
            return
        new_index %= len(configs)
        cfg = configs[new_index]
        positions = positions_by_config[cfg]
        if not positions:
            info_text.set_text("No positions recorded for this config.")
            clear_panels()
            return

        current_config_idx = new_index
        pos_idx = position_indices[cfg] % len(positions)
        pos = positions[pos_idx]

        is_updating = True
        config_box.set_val(cfg)
        position_box.set_val(f"{pos[0]},{pos[1]}")
        is_updating = False
        update_display("")

    def shift_position(delta: int) -> None:
        nonlocal is_updating
        if not configs:
            return
        cfg = configs[current_config_idx]
        positions = positions_by_config[cfg]
        if not positions:
            return
        new_index = (position_indices[cfg] + delta) % len(positions)
        position_indices[cfg] = new_index
        x_val, y_val = positions[new_index]

        is_updating = True
        position_box.set_val(f"{x_val},{y_val}")
        is_updating = False
        update_display("")

    config_box.on_submit(update_display)
    position_box.on_submit(update_display)

    config_prev_btn.on_clicked(lambda _: set_config(current_config_idx - 1))
    config_next_btn.on_clicked(lambda _: set_config(current_config_idx + 1))
    position_prev_btn.on_clicked(lambda _: shift_position(-1))
    position_next_btn.on_clicked(lambda _: shift_position(1))

    set_config(0)
    plt.show()


def group_similar_stereo_pairs(
    stack: torch.Tensor,
    metadata: Sequence[StereoPair],
    include_singletons: bool = False,
    per_channel_tolerance: float = 0.0,
    mean_tolerance: float = 0.0,
) -> List[List[str]]:
    """
    Group stereo tensors that match within configurable tolerances (png_compare-style).

    Args:
        stack: Tensor shaped (N, 2, H, W) containing left/right-eye pairs.
        metadata: StereoPair entries corresponding to each tensor in the stack.
        include_singletons: If True, include groups with only one element.
        per_channel_tolerance: Maximum allowed absolute per-pixel/channel difference.
            Values > 1 are interpreted on a 0-255 scale (mirroring png_compare).
            Set negative to skip the per-channel threshold.
        mean_tolerance: Maximum allowed mean absolute difference per pixel/channel.
            Values > 1 are interpreted on a 0-255 scale. Set negative to skip.

    Returns:
        A list of groups, where each group is the list of StereoPair.base identifiers
        whose tensors are considered duplicates within the provided tolerances.
    """
    if stack.ndim != 4 or stack.shape[1] != 2:
        raise ValueError("Expected stack with shape (N, 2, H, W).")
    if len(metadata) != stack.shape[0]:
        raise ValueError("Metadata length must match number of stereo pairs.")

    def _normalize_tolerance(value: float) -> float:
        if value < 0:
            return value
        if value > 1.0:
            return value / 255.0
        return value

    per_tol = _normalize_tolerance(per_channel_tolerance)
    mean_tol = _normalize_tolerance(mean_tolerance)

    tensors = stack.detach().cpu()

    def _pairs_similar(idx_a: int, idx_b: int) -> bool:
        diff = torch.abs(tensors[idx_a] - tensors[idx_b])
        max_diff = diff.max().item()
        mean_diff = diff.mean().item()

        if per_tol < 0 and mean_tol < 0:
            return max_diff == 0.0

        if per_tol >= 0 and max_diff > per_tol:
            return False
        if mean_tol >= 0 and mean_diff > mean_tol:
            return False
        return True

    size = tensors.shape[0]
    parent = list(range(size))

    def find(x: int) -> int:
        while parent[x] != x:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x

    def union(a: int, b: int) -> None:
        root_a, root_b = find(a), find(b)
        if root_a == root_b:
            return
        parent[root_b] = root_a

    for i in range(size):
        for j in range(i + 1, size):
            if _pairs_similar(i, j):
                union(i, j)

    clusters: Dict[int, List[int]] = {}
    for idx in range(size):
        root = find(idx)
        clusters.setdefault(root, []).append(idx)

    name_groups: List[List[str]] = []
    for indices in clusters.values():
        if include_singletons or len(indices) > 1:
            names = [metadata[i].base for i in indices]
            name_groups.append(sorted(names))

    name_groups.sort(key=lambda items: (-len(items), items[0]))
    return name_groups


if __name__ == "__main__":
    bundle_path = Path(
        "/Users/ryangrgurich/VS Code Local/corner-maze-encoder-pretrain/data/pt-files/all-views-dataset.pt"
    )
    stack, metadata, meta_info = load_dataset_bundle(bundle_path)
    print(f"Loaded dataset from {bundle_path.expanduser().resolve()}")
    print("Image stack shape:", tuple(stack.shape))
    if meta_info:
        print(f"Bundle meta: {meta_info}")
    stereo_pair_display(stack, metadata, view_mode='single', direction='N')
    # similar_pairs = group_similar_stereo_pairs(stack, metadata, 10, 0.5)
    # for group in similar_pairs:
    #     print(group)
